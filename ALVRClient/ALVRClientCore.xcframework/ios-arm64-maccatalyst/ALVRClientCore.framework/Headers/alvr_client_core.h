/* ALVR is licensed under the MIT license. https://github.com/alvr-org/ALVR/blob/master/LICENSE */

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

enum AlvrCodec
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_CODEC_H264 = 0,
    ALVR_CODEC_HEVC = 1,
    ALVR_CODEC_AV1 = 2,
};
#ifndef __cplusplus
typedef uint8_t AlvrCodec;
#endif // __cplusplus

enum AlvrLogLevel
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_LOG_LEVEL_ERROR,
    ALVR_LOG_LEVEL_WARN,
    ALVR_LOG_LEVEL_INFO,
    ALVR_LOG_LEVEL_DEBUG,
};
#ifndef __cplusplus
typedef uint8_t AlvrLogLevel;
#endif // __cplusplus

enum AlvrMediacodecPropType
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_MEDIACODEC_PROP_TYPE_FLOAT,
    ALVR_MEDIACODEC_PROP_TYPE_INT32,
    ALVR_MEDIACODEC_PROP_TYPE_INT64,
    ALVR_MEDIACODEC_PROP_TYPE_STRING,
};
#ifndef __cplusplus
typedef uint8_t AlvrMediacodecPropType;
#endif // __cplusplus

typedef struct AlvrClientCapabilities {
    uint32_t default_view_width;
    uint32_t default_view_height;
    const float *refresh_rates;
    uint64_t refresh_rates_count;
    bool foveated_encoding;
    bool encoder_high_profile;
    bool encoder_10_bits;
    bool encoder_av1;
    bool prefer_10bit;
    bool prefer_full_range;
    float preferred_encoding_gamma;
    bool prefer_hdr;
} AlvrClientCapabilities;

enum AlvrEvent_Tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_EVENT_HUD_MESSAGE_UPDATED,
    ALVR_EVENT_STREAMING_STARTED,
    ALVR_EVENT_STREAMING_STOPPED,
    ALVR_EVENT_HAPTICS,
    // Note: All subsequent DecoderConfig events should be ignored until reconnection
    ALVR_EVENT_DECODER_CONFIG,
    ALVR_EVENT_REAL_TIME_CONFIG,
};
#ifndef __cplusplus
typedef uint8_t AlvrEvent_Tag;
#endif // __cplusplus

typedef struct StreamingStarted_Body {
    AlvrEvent_Tag tag;
    uint32_t view_width;
    uint32_t view_height;
    float refresh_rate_hint;
    float encoding_gamma;
    bool enable_foveated_encoding;
    bool enable_hdr;
} StreamingStarted_Body;

typedef struct Haptics_Body {
    AlvrEvent_Tag tag;
    uint64_t device_id;
    float duration_s;
    float frequency;
    float amplitude;
} Haptics_Body;

typedef struct DecoderConfig_Body {
    AlvrEvent_Tag tag;
    AlvrCodec codec;
} DecoderConfig_Body;

typedef struct RealTimeConfig_Body {
    AlvrEvent_Tag tag;
} RealTimeConfig_Body;

typedef union AlvrEvent {
    AlvrEvent_Tag tag;
    StreamingStarted_Body STREAMING_STARTED;
    Haptics_Body HAPTICS;
    DecoderConfig_Body DECODER_CONFIG;
    RealTimeConfig_Body REAL_TIME_CONFIG;
} AlvrEvent;

typedef enum AlvrButtonValue_Tag {
    ALVR_BUTTON_VALUE_BINARY,
    ALVR_BUTTON_VALUE_SCALAR,
} AlvrButtonValue_Tag;

typedef struct AlvrButtonValue {
    AlvrButtonValue_Tag tag;
    union {
        struct {
            bool binary;
        };
        struct {
            float scalar;
        };
    };
} AlvrButtonValue;

typedef struct AlvrQuat {
    float x;
    float y;
    float z;
    float w;
} AlvrQuat;

typedef struct AlvrPose {
    struct AlvrQuat orientation;
    float position[3];
} AlvrPose;

typedef struct AlvrFov {
    float left;
    float right;
    float up;
    float down;
} AlvrFov;

typedef struct AlvrViewParams {
    struct AlvrPose pose;
    struct AlvrFov fov;
} AlvrViewParams;

typedef struct AlvrDeviceMotion {
    uint64_t device_id;
    struct AlvrPose pose;
    float linear_velocity[3];
    float angular_velocity[3];
} AlvrDeviceMotion;

typedef struct AlvrVideoFrameData {
    void *callback_context;
    uint64_t timestamp_ns;
    const uint8_t *buffer_ptr;
    uint64_t buffer_size;
} AlvrVideoFrameData;

typedef struct AlvrStreamConfig {
    uint32_t view_resolution_width;
    uint32_t view_resolution_height;
    const uint32_t **swapchain_textures;
    uint32_t swapchain_length;
    bool enable_foveation;
    float foveation_center_size_x;
    float foveation_center_size_y;
    float foveation_center_shift_x;
    float foveation_center_shift_y;
    float foveation_edge_ratio_x;
    float foveation_edge_ratio_y;
    bool enable_upscaling;
    bool upscaling_edge_direction;
    float upscaling_edge_threshold;
    float upscaling_edge_sharpness;
    float upscale_factor;
} AlvrStreamConfig;

typedef struct AlvrLobbyViewParams {
    uint32_t swapchain_index;
    struct AlvrPose pose;
    struct AlvrFov fov;
} AlvrLobbyViewParams;

typedef struct AlvrStreamViewParams {
    uint32_t swapchain_index;
    struct AlvrQuat reprojection_rotation;
    struct AlvrFov fov;
} AlvrStreamViewParams;

typedef union AlvrMediacodecPropValue {
    float float_;
    int32_t int32;
    int64_t int64;
    const char *string;
} AlvrMediacodecPropValue;

typedef struct AlvrMediacodecOption {
    const char *key;
    AlvrMediacodecPropType ty;
    union AlvrMediacodecPropValue value;
} AlvrMediacodecOption;

typedef struct AlvrDecoderConfig {
    AlvrCodec codec;
    bool force_software_decoder;
    float max_buffering_frames;
    float buffering_history_weight;
    const struct AlvrMediacodecOption *options;
    uint64_t options_count;
    const uint8_t *config_buffer;
    uint64_t config_buffer_size;
} AlvrDecoderConfig;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void alvr_initialize_logging(void);

uint64_t alvr_path_string_to_id(const char *path);

void alvr_log(AlvrLogLevel level, const char *message);

void alvr_dbg_client_impl(const char *message);

void alvr_dbg_decoder(const char *message);

void alvr_log_time(const char *tag);

uint64_t alvr_mdns_service(char *service_buffer);

// To make sure the value is correct, call after alvr_initialize()
uint64_t alvr_hostname(char *hostname_buffer);

// To make sure the value is correct, call after alvr_initialize()
uint64_t alvr_protocol_id(char *protocol_buffer);

void alvr_try_get_permission(const char *permission);

// NB: for android, `context` must be thread safe.
void alvr_initialize_android_context(void *java_vm, void *context);

// On android, alvr_initialize_android_context() must be called first, then alvr_initialize().
void alvr_initialize(struct AlvrClientCapabilities capabilities);

void alvr_destroy(void);

void alvr_resume(void);

void alvr_pause(void);

// Returns true if there was a new event
bool alvr_poll_event(union AlvrEvent *out_event);

uint64_t alvr_hud_message(char *message_buffer);

// Settings will be updated after receiving StreamingStarted event
uint64_t alvr_get_settings_json(char *out_buffer);

// Will be updated after receiving StreamingStarted event
uint64_t alvr_get_server_version(char *out_buffer);

// Returns the number of bytes of the decoder_buffer
uint64_t alvr_get_decoder_config(char *out_buffer);

void alvr_send_battery(uint64_t device_id, float gauge_value, bool is_plugged);

void alvr_send_playspace(float width, float height);

void alvr_send_active_interaction_profile(uint64_t device_id, uint64_t profile_id);

void alvr_send_custom_interaction_profile(uint64_t device_id,
                                          const uint64_t *input_ids_ptr,
                                          uint64_t input_ids_count);

void alvr_send_button(uint64_t path_id, struct AlvrButtonValue value);

// The view poses need to be in local space, as if the head is at the origin.
// view_params: array of 2
void alvr_send_view_params(const struct AlvrViewParams *view_params);

// hand_skeleton:
// * outer ptr: array of 2 (can be null);
// * inner ptr: array of 26 (can be null if hand is absent)
//
// eye_gazes:
// * outer ptr: array of 2 (can be null);
// * inner ptr: pose (can be null if eye gaze is absent)
void alvr_send_tracking(uint64_t poll_timestamp_ns,
                        const struct AlvrDeviceMotion *device_motions,
                        uint64_t device_motions_count,
                        const struct AlvrPose *const *hand_skeletons,
                        const struct AlvrPose *const *eye_gazes);

// Safety: `context` must be thread safe and valid until the StreamingStopped event.
void alvr_set_decoder_input_callback(void *callback_context,
                                     bool (*callback)(struct AlvrVideoFrameData));

void alvr_report_frame_decoded(uint64_t target_timestamp_ns);

void alvr_report_fatal_decoder_error(const char *message);

// out_view_params must be a vector of 2 elements
// out_view_params is populated only if the core context is valid
void alvr_report_compositor_start(uint64_t target_timestamp_ns,
                                  struct AlvrViewParams *out_view_params);

void alvr_report_submit(uint64_t target_timestamp_ns, uint64_t vsync_queue_ns);

void alvr_initialize_opengl(void);

void alvr_destroy_opengl(void);

void alvr_resume_opengl(uint32_t preferred_view_width,
                        uint32_t preferred_view_height,
                        const uint32_t **swapchain_textures,
                        uint32_t swapchain_length);

void alvr_pause_opengl(void);

void alvr_update_hud_message_opengl(const char *message);

void alvr_start_stream_opengl(struct AlvrStreamConfig config);

void alvr_render_lobby_opengl(const struct AlvrLobbyViewParams *view_inputs,
                              bool render_background);

// view_params: array of 2
void alvr_render_stream_opengl(void *hardware_buffer,
                               const struct AlvrStreamViewParams *view_params);

// alvr_initialize() must be called before alvr_create_decoder
void alvr_create_decoder(struct AlvrDecoderConfig config);

void alvr_destroy_decoder(void);

bool alvr_get_frame(uint64_t *out_timestamp_ns, void **out_buffer_ptr);

struct AlvrQuat alvr_rotation_delta(struct AlvrQuat source, struct AlvrQuat destination);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
